package main

import (
	"bytes"
	"fmt"
	"math/rand"
	"strconv"
)

// square
// -------------------------

type square struct {
	m   [][]int // the square
	msk [][]bool
	d   density
	alg string // the algorithm used to generate the square
}

type density float64

const (
	FULL density = 0
	HIGH density = 0.25
	MID  density = 0.5
	LOW  density = 0.75
)

func (sq *square) init(n int) {
	sq.m = make([][]int, n)
	sq.msk = make([][]bool, n)
	m := make([]int, n*n)
	msk := make([]bool, n*n)
	for i := range sq.m {
		sq.m[i] = m[n*i : n*(i+1)]
		sq.msk[i] = msk[n*i : n*(i+1)]
	}
}

func (sq *square) String() string {
	var d string
	switch sq.d {
	case FULL:
		d = "soln"
	case HIGH:
		d = "easy"
	case MID:
		d = "med"
	case LOW:
		d = "hard"
	}
	n := len(sq.m)
	var buf bytes.Buffer
	buf.WriteString("[")
	for i := range sq.m {
		if i != 0 {
			buf.WriteString(",")
		}
		buf.WriteString("[")
		for j := range sq.m[i] {
			if j != 0 {
				buf.WriteString(",")
			}
			if sq.msk[i][j] {
				buf.WriteString("_")
			} else {
				buf.WriteString(strconv.Itoa(sq.m[i][j]))
			}
		}
		buf.WriteString("]")
	}
	buf.WriteString("]")
	return fmt.Sprintf("trial(%v, %v, %v, %v).", n, sq.alg, d, buf.String())
}

func (sq *square) reflectX() {
	n := len(sq.m)
	for y := 0; y < n; y++ {
		for x := 0; x < n/2; x++ {
			sq.m[y][x], sq.m[y][n-x-1] = sq.m[y][n-x-1], sq.m[y][x]
		}
	}
}

func (sq *square) reflectY() {
	n := len(sq.m)
	for y := 0; y < n/2; y++ {
		for x := 0; x < n; x++ {
			sq.m[y][x], sq.m[n-y-1][x] = sq.m[n-y-1][x], sq.m[y][x]
		}
	}
}

func (sq *square) transpose() {
	n := len(sq.m)
	for i := 0; i < n; i++ {
		for j := i; j < n; j++ {
			sq.m[i][j], sq.m[j][i] = sq.m[j][i], sq.m[i][j]
		}
	}
}

func (sq *square) shuffle() {
	if rand.Float64() < 0.5 {
		sq.reflectX()
	}
	if rand.Float64() < 0.5 {
		sq.reflectY()
	}
	if rand.Float64() < 0.5 {
		sq.transpose()
	}
}

func (sq *square) mask(d density) {
	n := len(sq.m)
	sq.msk = make([][]bool, n)
	sq.d = d
	arr := make([]bool, n*n)
	for i := range sq.msk {
		sq.msk[i] = arr[n*i : n*(i+1)]
	}
	count := float64(0)
	for {
		for i := range arr {
			if float64(d) <= count/float64(n*n) {
				return
			}
			if !arr[i] && rand.Float64() < 0.5 {
				arr[i] = true
				count++
			}
		}
	}
}

// cursor
// -------------------------

type cursor struct {
	*square
	x, y int
}

func (c *cursor) read() int {
	return c.m[c.y][c.x]
}

func (c *cursor) write(n int) {
	c.m[c.y][c.x] = n
}

func (c *cursor) set(y, x int) {
	c.x, c.y = x, y
}

func (c *cursor) move(dy, dx int) {
	dim := len(c.m)
	c.x += dx
	c.y += dy
	for c.x < 0 {
		c.x += dim
	}
	for c.y < 0 {
		c.y += dim
	}
	c.x %= dim
	c.y %= dim
}

// generators
// -------------------------

func Siamese1(n int) (sq square) {
	if n%2 == 0 {
		panic("Siamese1 must be called with odd order")
	}
	sq.init(n)
	sq.alg = "siamese1"
	c := cursor{square: &sq}
	c.set(0, n/2)
	for i := 0; i < n*n; i++ {
		c.write(i + 1)
		if i%n == n-1 {
			c.move(+1, 0)
		} else {
			c.move(-1, +1)
		}
	}
	return sq
}

func Siamese2(n int) (sq square) {
	if n%2 == 0 {
		panic("Siamese2 must be called with odd order")
	}
	sq.init(n)
	sq.alg = "siamese2"
	c := cursor{square: &sq}
	c.set(n/2-1, n/2)
	for i := 0; i < n*n; i++ {
		c.write(i + 1)
		if i%n == n-1 {
			c.move(-2, 0)
		} else {
			c.move(-1, +1)
		}
	}
	return sq
}

func Fours(n int) (sq square) {
	if n%4 != 0 {
		panic("Fours must called with doubly even order")
	}
	sq.init(n)
	sq.alg = "fours"
	c := cursor{square: &sq}
	v := 1
	for y := 0; y < n; y++ {
		for x := 0; x < n; x++ {
			c.set(y, x)
			if ((y%4 == 0 || y%4 == 3) && (x%4 == 0 || x%4 == 3)) ||
				((y%4 == 1 || y%4 == 2) && (x%4 == 1 || x%4 == 2)) {
				c.write(n*n + 1 - v)
			} else {
				c.write(v)
			}
			v++
		}
	}
	return sq
}

func Lux(n int) (sq square) {
	if (n-2)%4 != 0 || n < 6 {
		panic("Lux must be called with singly even order, n >= 6")
	}
	sq.init(n)
	sq.alg = "lux"
	m := (n - 2) / 4
	c := cursor{square: &sq}

	l := func(i int) {
		c.write(i + 1)
		c.move(+1, -1)
		c.write(i + 2)
		c.move(0, +1)
		c.write(i + 3)
		c.move(-1, -1)
		c.write(i + 4)
		c.move(0, +1)
	}
	u := func(i int) {
		c.move(0, -1)
		c.write(i + 1)
		c.move(+1, 0)
		c.write(i + 2)
		c.move(0, +1)
		c.write(i + 3)
		c.move(-1, 0)
		c.write(i + 4)
	}
	x := func(i int) {
		c.move(0, -1)
		c.write(i + 1)
		c.move(+1, +1)
		c.write(i + 2)
		c.move(0, -1)
		c.write(i + 3)
		c.move(-1, +1)
		c.write(i + 4)
	}

	c.set(0, n/2)
	for i := 0; i < n*n; i += 4 {
		switch {
		case c.y < n/2:
			if c.y == n/2-1 && c.x == n/2 {
				u(i)
			} else {
				l(i)
			}
		case c.y < 2*(m+2):
			if c.x == n/2 {
				l(i)
			} else {
				u(i)
			}
		default:
			x(i)
		}
		if (i/4)%(n/2) == (n/2)-1 {
			c.move(+2, 0)
		} else {
			c.move(-2, +2)
		}
	}
	return sq
}

func main() {
	var sq square

	fmt.Println("% DO NOT EDIT")
	fmt.Println("% This file was generated by `gen.go` and is specially formatted")
	fmt.Println("% to be parsed by both Go and Prolog. The syntax is more strict")
	fmt.Println("% than standard Prolog.")

	fmt.Println()
	fmt.Println("%% trial(+Order, +Generator, +Difficulty, +Square)")
	fmt.Println("% This predicate gives trials for the magic square experiments")
	fmt.Println("% where Order is the size of one dimension the Square and Generator")
	fmt.Println("% is the algorithm used to generate the trial. All test cases for")
	fmt.Println("% the same Order and Generator represent the same square. Each")
	fmt.Println("% trial is given a Difficulty indicating the number of variables")
	fmt.Println("% in the square. A Difficulty of 'soln' has no variables.")
	fmt.Println()

	sq = Siamese1(3)
	sq.shuffle()
	fmt.Println(sq.String())
	sq.mask(HIGH)
	fmt.Println(sq.String())
	sq.mask(MID)
	fmt.Println(sq.String())
	sq.mask(LOW)
	fmt.Println(sq.String())
	fmt.Println()

	sq = Siamese1(5)
	sq.shuffle()
	fmt.Println(sq.String())
	sq.mask(HIGH)
	fmt.Println(sq.String())
	sq.mask(MID)
	fmt.Println(sq.String())
	sq.mask(LOW)
	fmt.Println(sq.String())
	fmt.Println()

	sq = Siamese1(7)
	sq.shuffle()
	fmt.Println(sq.String())
	sq.mask(HIGH)
	fmt.Println(sq.String())
	sq.mask(MID)
	fmt.Println(sq.String())
	sq.mask(LOW)
	fmt.Println(sq.String())
	fmt.Println()

	sq = Siamese2(3)
	sq.shuffle()
	fmt.Println(sq.String())
	sq.mask(HIGH)
	fmt.Println(sq.String())
	sq.mask(MID)
	fmt.Println(sq.String())
	sq.mask(LOW)
	fmt.Println(sq.String())
	fmt.Println()

	sq = Siamese2(5)
	sq.shuffle()
	fmt.Println(sq.String())
	sq.mask(HIGH)
	fmt.Println(sq.String())
	sq.mask(MID)
	fmt.Println(sq.String())
	sq.mask(LOW)
	fmt.Println(sq.String())
	fmt.Println()

	sq = Siamese2(7)
	sq.shuffle()
	fmt.Println(sq.String())
	sq.mask(HIGH)
	fmt.Println(sq.String())
	sq.mask(MID)
	fmt.Println(sq.String())
	sq.mask(LOW)
	fmt.Println(sq.String())
	fmt.Println()

	sq = Fours(4)
	sq.shuffle()
	fmt.Println(sq.String())
	sq.mask(HIGH)
	fmt.Println(sq.String())
	sq.mask(MID)
	fmt.Println(sq.String())
	sq.mask(LOW)
	fmt.Println(sq.String())
	fmt.Println()

	sq = Fours(8)
	sq.shuffle()
	fmt.Println(sq.String())
	sq.mask(HIGH)
	fmt.Println(sq.String())
	sq.mask(MID)
	fmt.Println(sq.String())
	sq.mask(LOW)
	fmt.Println(sq.String())
	fmt.Println()

	sq = Lux(6)
	sq.shuffle()
	fmt.Println(sq.String())
	sq.mask(HIGH)
	fmt.Println(sq.String())
	sq.mask(MID)
	fmt.Println(sq.String())
	sq.mask(LOW)
	fmt.Println(sq.String())
	fmt.Println()

	sq = Lux(10)
	sq.shuffle()
	fmt.Println(sq.String())
	sq.mask(HIGH)
	fmt.Println(sq.String())
	sq.mask(MID)
	fmt.Println(sq.String())
	sq.mask(LOW)
	fmt.Println(sq.String())
	fmt.Println()
}
